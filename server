#!/usr/bin/env node

var express = require('express')
  , bodyParser = require('body-parser')
  , querystring = require('querystring')
  , program = require('commander')
  , crypto = require('crypto')
  , util = require('util')
  , fs = require('fs')
  , request = require('request')
  , app = express()
  , mode = 'http'

function requiredArgument(arg) {
  console.error('\n  ' + arg + ' argument is required');
  program.help();
  process.exit(1);
}

program
  .version('0.0.1')
  .option('-a, --account <account>', 'Vivocha account')
  .option('-u, --user <user>', 'Vivocha user (must be an admin user)')
  .option('-p, --password <password>', 'Vivocha user password')
  .option('-r, --agent <agent>', 'Vivocha agent id to which the token is created')
  .option('-H, --host <host>', 'Webhook host (host must be reachable from the internet)')
  .option('-P, --port [port]', 'Webhook port (default: 80, 443 if https is enabled)')
  .option('-k, --key <key>', 'HTTPS key')
  .option('-c, --cert <cert>', 'HTTPS cert')
  .parse(process.argv);

if (!program.account) requiredArgument('account');
if (!program.user) requiredArgument('user');
if (!program.password) requiredArgument('password');
if (!program.agent) requiredArgument('agent');
if (!program.host) requiredArgument('host');

if (program.key && program.cert) {
  mode = 'https';
  http = require('https').createServer(
    {
      key: fs.readFileSync(program.key),
      cert: fs.readFileSync(program.cert)
    }, app)
} else {
  http = require('http').Server(app)
}

var io = require('socket.io')(http)

// application global parameters
var __localport = program.port || (mode === 'http' ? 80 : 443)       // local listen port
  , __host = program.port ? (program.host + ':' + program.port) : program.host;  // host this must be reachable from the internet

var __vvcAcct = program.account         // your vivocha account
  , __vvcUser = program.user            // your vivocha userid
  , __vvcPass = program.password        // your vivocha password
  , __vvcHost = "m1.vivocha.com"        // your vivocha host (usually www.vivocha.com)
  , __vvcPath = "/a/" + __vvcAcct + "/api/_/"
  , __vvcAgent = program.agent          // the agent id
  , webhookUrl = mode + "://"+__host+"/vivochaEvents"
  , registerMediaUrl = mode + "://"+__host+"/vivochaAgents"
  , subscribeParams = {
      url: webhookUrl,
      external_routing: 1, // If true this param stops the propagation of the new event to the agents
      events: JSON.stringify(["new"])
    }
  , registerMediaParams = {
      url: registerMediaUrl
    }

function subscribeToVivocha () {
  request({
      url : "https://" + __vvcHost + __vvcPath + "account/subscribe/?" + querystring.stringify(subscribeParams),
      headers : {
        "Accept": "application/json",
      },
      auth: {
        username: __vvcUser,
        password: __vvcPass
      },
      removeRefererHeader: true
    },
    function (err, res, body) {
      if (err) {
        console.error("subscribeToVivocha error", err);
      } else {
        console.log('subscribeToVivocha res', res.headers, body);
      }
    }
  );
}
function registerMediaToVivocha () {
  request({
      url : "https://" + __vvcHost + __vvcPath + "account/registerMediaHook/?" + querystring.stringify(registerMediaParams),
      headers : {
        "Accept": "application/json",
      },
      auth: {
        username: __vvcUser,
        password: __vvcPass
      },
      removeRefererHeader: true
    },
    function (err, res, body) {
      if (err) {
        console.error("registerMediaToVivocha error", err);
      } else {
        console.log('registerMediaToVivocha res', res.headers, body);
      }
    }
  );
}
function getRoutingToken (cid, user, cb) {
  request({
      url : "https://" + __vvcHost + __vvcPath + "contact/routingToken/?" + querystring.stringify({cid: cid, user: user}),
      headers : {
        "Accept": "application/json",
      },
      auth: {
        username: __vvcUser,
        password: __vvcPass
      },
      removeRefererHeader: true
    },
    function (err, res, body) {
      if (err) {
        console.error("getRoutingToken error", err);
        cb(err);
      } else {
        try {
          console.log('getRoutingToken res', res.headers, body);
          var token = JSON.parse(body);
          cb(null, token);
        } catch(e) {
          cb(e);
        }
      }
    }
  );
}
function getContactInfo (_cid) {
  request({
      url : "https://" + __vvcHost + __vvcPath + "contact/get/?" + querystring.stringify({cid: _cid, full: 1}),
      headers : {
        "Accept": "application/json",
        //"Authorization": getAuth()
      },
      auth: {
        username: __vvcUser,
        password: __vvcPass
      },
      removeRefererHeader: true
    },
    function (err, res, body) {
      if (err) {
        console.error("getContactInfo error", err);
      } else {
        console.log('getContactInfo res', res.headers, body);
      }
    }
  );
}
function unsubscribe () {
  request({
      url : "https://" + __vvcHost + __vvcPath + "account/unsubscribe/",
      headers : {
        "Accept": "application/json",
        //"Authorization": getAuth()
      },
      auth: {
        username: __vvcUser,
        password: __vvcPass
      },
      removeRefererHeader: true
    },
    function (err, res, body) {
      if (err) {
        console.error("unsubscribe error", err);
      } else {
        console.log('unsubscribe res', res.headers, body);
      }
    }
  );
}
function processEvent(ev) {
  console.log("NEW EVENT", ev);
  switch (ev.event) {
    case "new":
      console.log('new contact event received, getting token for contact', ev.cid);
      // place your code to decide to which agent forward the token here
      getRoutingToken(ev.cid, __vvcAgent, function (err, token) {
        token.cid = ev.cid;
        console.log('token received', token, err);
        io.emit('token', token);
      });
      break;
    case "end":
      getContactInfo(ev.cid);
      break;
    case "changed":
      getContactInfo(ev.cid);
      break;
    default:
      break;
  }
}

app.use(express.static('views'));
app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json());
app.all('/vivochaEvents', function(req, res, next) {
  //console.log(req.body);
  if (util.isArray(req.body)) {
    for (var i = 0 ; i < req.body.length ; i++) {
      processEvent(req.body[i]);
    }
  } else {
    processEvent(req.body);
  }
  res.jsonp({result: true, reason: "this is a test message"});
});
app.all('/vivochaAgents', function(req, res, next) {
  console.log(req.query);
  // place your agents availability code here
  res.jsonp({
    chat: true,
    cbn: true,
    cbl: []
  });
});
app.all('/unsubscribe', function(req, res, next) {
  unsubscribe();
  res.jsonp({result: true, reason: "done!"});
});

io.on('connection', function(socket){
  console.log('a user connected');
  socket.on('disconnect', function(){
    console.log('user disconnected');
  });
});

http.listen(__localport, function(){
  console.log('listening on *:' + __localport);
  subscribeToVivocha();
  registerMediaToVivocha();
});

setInterval(subscribeToVivocha, 240000);
setInterval(registerMediaToVivocha, 240000);
